<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Positional Encoding Visualization with Interactive Graphs</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        #plot { width: 100%; height: 600px; }
        #linePlot { width: 100%; height: 400px; margin-top: 20px; }
        #dimensionSelector { margin-top: 20px; }
        label { font-weight: bold; }
    </style>
</head>
<body>
    <h1>3D Positional Encoding Visualization with Interactive Graphs</h1>
    <div id="plot"></div>
    <div id="dimensionSelector">
        <label for="dimension">Select Encoding Dimension:</label>
        <input type="number" id="dimension" name="dimension" min="0" max="63" value="0">
        <button id="updateButton">Update Graph</button>
    </div>
    <div id="linePlot"></div>
    <script>
        function generateData() {
            const x = [];
            const y = [];
            const z = [];
            const colors = [];
            const timeSteps = [];
            const dimensionValues = {};

            for (let t = -30; t <= 90; t++) {
                timeSteps.push(t);
                let intensity = 0;
                if (t < 0) {
                    intensity = Math.min(1, (t + 30) / 30);
                } else if (t <= 90) {
                    intensity = 0.7 + Math.sin(t * Math.PI / 45) * 0.3;
                }

                if (t === 23 || t === 78) intensity = 1;
                if (t === 52) intensity = 0.9;

                for (let i = 0; i < 64; i++) {
                    let val = i % 2 === 0 ?
                        Math.sin(t / Math.pow(10000, 2 * i / 64)) :
                        Math.cos(t / Math.pow(10000, 2 * (i - 1) / 64));

                    if ((t === 23 || t === 78 || t === 52) && i < 20) val *= 2;

                    x.push(t);
                    y.push(i);
                    z.push(val * intensity);
                    colors.push(val * intensity);

                    if (!dimensionValues[i]) {
                        dimensionValues[i] = [];
                    }
                    dimensionValues[i].push(val * intensity);
                }
            }

            return { x, y, z, colors, timeSteps, dimensionValues };
        }

        const { x, y, z, colors, timeSteps, dimensionValues } = generateData();

        const data = [{
            x: x,
            y: y,
            z: z,
            mode: 'markers',
            marker: {
                size: 2,
                color: colors,
                colorscale: 'RdYlBu',
                colorbar: {
                    title: 'Encoding Value',
                },
                opacity: 0.7,
            },
            type: 'scatter3d',
            name: 'Positional Encoding',
        }];

        // Adding Game Events
        const gameEvents = [
            { time: -30, event: "Fans Entering Stadium" },
            { time: 0, event: "Kickoff" },
            { time: 23, event: "Goal (Team A)" },
            { time: 52, event: "Red Card (Team B)" },
            { time: 78, event: "Goal (Team B)" },
            { time: 90, event: "End of Game" }
        ];

        const eventMarkers = {
            x: gameEvents.map(e => e.time),
            y: gameEvents.map(() => 32), // Middle of encoding dimensions
            z: gameEvents.map(() => 0), // Base plane
            mode: 'markers+text',
            marker: {
                size: 5,
                color: 'black',
                symbol: 'diamond',
            },
            text: gameEvents.map(e => e.event),
            textposition: 'top center',
            type: 'scatter3d',
            name: 'Game Events',
            hoverinfo: 'text',
        };

        data.push(eventMarkers);

        const layout = {
            scene: {
                xaxis: { title: 'Time (minutes)' },
                yaxis: { title: 'Encoding Dimension' },
                zaxis: { title: 'Value' },
            },
            margin: { l: 0, r: 0, b: 0, t: 50 },
            title: '3D Positional Encoding Visualization with Game Events',
            legend: { x: 0.8, y: 0.9 },
        };

        Plotly.newPlot('plot', data, layout);

        // Interactive Value-Time Graph
        function updateLinePlot(dimension) {
            const values = dimensionValues[dimension];
            const trace = {
                x: timeSteps,
                y: values,
                mode: 'lines+markers',
                marker: {
                    color: 'blue',
                },
                line: {
                    color: 'blue',
                },
                name: `Dimension ${dimension}`,
            };

            const eventLines = gameEvents.map(event => {
                return {
                    x: [event.time, event.time],
                    y: [Math.min(...values), Math.max(...values)],
                    mode: 'lines',
                    line: {
                        color: 'red',
                        width: 1,
                        dash: 'dashdot',
                    },
                    name: event.event,
                    hoverinfo: 'none',
                };
            });

            const lineLayout = {
                xaxis: { title: 'Time (minutes)' },
                yaxis: { title: 'Value' },
                title: `Value-Time Graph for Encoding Dimension ${dimension}`,
                showlegend: false,
            };

            const lineData = [trace, ...eventLines];

            Plotly.newPlot('linePlot', lineData, lineLayout);
        }

        // Initial Plot
        updateLinePlot(0);

        // Event Listener for Dimension Selector
        document.getElementById('updateButton').addEventListener('click', () => {
            const dimensionInput = document.getElementById('dimension');
            let dimension = parseInt(dimensionInput.value);
            if (isNaN(dimension) || dimension < 0 || dimension > 63) {
                alert('Please enter a valid dimension between 0 and 63.');
                return;
            }
            updateLinePlot(dimension);
        });
    </script>
</body>
</html>